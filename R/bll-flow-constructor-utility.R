#' Creates a data frame that holds additional ddi data
#'
#' @param frameToPopulateFrom The dataframe that contais the variable information 
#' that is used to populate the frame with relevant ddi info
#' @param labeledVariables an object that is generated by populateVariables
#' it contains the variables as well as all their value labels and min and max
#' @param variablesBeingChanged List of the variables that are being changed
#' @return returns a dataframe containing new ddi data
PopulateVariableDetails <-
  function(frameToPopulateFrom,
           labeledVariables,
           variablesBeingChanged) {
    # Used to group all the variables in the dataframe
    frameToPopulateFrom <-
      frameToPopulateFrom[order(frameToPopulateFrom$variableStart,
                                frameToPopulateFrom$catStartValue),]
    onlyDesiredVariables <-
      frameToPopulateFrom[frameToPopulateFrom$variableStart %in% names(labeledVariables), ]
    variablesNotRelatedToTheDDI <-
      frameToPopulateFrom[!frameToPopulateFrom$variableStart %in% names(labeledVariables), ]
    variablesBeingChanged <-
      unique(onlyDesiredVariables[pkg.globals$argument.VariableStart])
    # Copy all the columns
    finalFrame <- onlyDesiredVariables[0, ]
    for (nameIndex in 1:length(names(labeledVariables))) {
      nameBeingChecked <- names(labeledVariables)[[nameIndex]]
      # All the rows for the variable being checked
      rowsToCheck <-
        onlyDesiredVariables[onlyDesiredVariables$variableStart == nameBeingChecked,]
      # Writes data to relavant rows and removes them from the value object
      for (rowToCheck in 1:nrow(rowsToCheck)) {
        presentCatStartValue <-
          rowsToCheck[rowToCheck, pkg.globals$argument.CatStartValue]
        # Check if the value matches anything in the DDI object
        if (presentCatStartValue %in% names(labeledVariables[[nameBeingChecked]])) {
          # Populate every column with values pulled from DDI
          for (columnName in names(labeledVariables[[nameBeingChecked]][[as.character(presentCatStartValue)]])) {
            if (columnName != pkg.globals$argument.CatStartValue) {
              # Check if there is any data precent in the cell in order to not override anything
              if (CheckIfCellIsEmpty(rowsToCheck[rowToCheck, columnName],
                                     rownames(rowsToCheck)[rowToCheck],
                                     columnName,
                                     labeledVariables[[nameBeingChecked]][[as.character(presentCatStartValue)]][[columnName]])) {
                # If this has not been in the dataframe upon creation that level is added
                if (!labeledVariables[[nameBeingChecked]][[as.character(presentCatStartValue)]][[columnName]] %in% levels(rowsToCheck[, columnName])) {
                  levels(rowsToCheck[, columnName]) <-
                    c(levels(rowsToCheck[, columnName]), labeledVariables[[nameBeingChecked]][[as.character(presentCatStartValue)]][[columnName]])
                }
                rowsToCheck[rowToCheck, columnName] <-
                  labeledVariables[[nameBeingChecked]][[as.character(presentCatStartValue)]][[columnName]]
              }
            }
          }
          # Remove that value from the list to avoid repetition during new row creation
          labeledVariables[[nameBeingChecked]][[as.character(presentCatStartValue)]] <-
            NULL
          finalFrame <- rbind(finalFrame, rowsToCheck[rowToCheck, ])
        } else{
          # leave the row untouched if no value is matched
          finalFrame <- rbind(finalFrame, rowsToCheck[rowToCheck,])
        }
      }
      # Create new Rows for leftover data
      for (leftOverValue in names(labeledVariables[[nameBeingChecked]])) {
        rowToAdd <-  onlyDesiredVariables[0, ]
        for (columnName in names(labeledVariables[[nameBeingChecked]][[leftOverValue]])) {
          if (!labeledVariables[[nameBeingChecked]][[as.character(leftOverValue)]][[columnName]] %in% levels(rowToAdd[, columnName])) {
            levels(rowToAdd[, columnName]) <-
              c(levels(rowToAdd[, columnName]), labeledVariables[[nameBeingChecked]][[as.character(leftOverValue)]][[columnName]])
          }
          rowToAdd[1, columnName] <-
            labeledVariables[[nameBeingChecked]][[leftOverValue]][[columnName]]
        }
        rowToAdd[1, pkg.globals$argument.VariableStart] <-
          nameBeingChecked
        finalFrame <- rbind(finalFrame, rowToAdd)
      }
    }
    finalFrame <- rbind(finalFrame, variablesNotRelatedToTheDDI)
    rownames(finalFrame) <- NULL
    
    return(finalFrame)
  }

#' Creates a DDI object containing the metadata as well as object of overall DDI
#'
#' @param ddiPath path to the directory containing the ddi file
#' that is used to populate the frame with relevant ddi info
#' @param ddiFile the name of the DDI file
#' @return returns a list containing ddiMetadata and ddi xml parsed object
#' @export
ReadDDI <- function(ddiPath, ddiFile){
  # DDwR crates lots of cat outputs that are suppressed
  print(paste(ddiPath, ddiFile, sep = "/"))
  ddiMetaData <-
    SupressFunctionCatOutput(DDIwR::getMetadata(paste(ddiPath, ddiFile, sep = "/")))
  additionalDDIMetaData <- xml2::as_list(xml2::read_xml(paste(ddiPath, ddiFile, sep = "/")))
  return(list(variableMetaData = ddiMetaData, ddiObject = additionalDDIMetaData))
}

#' Checks if content of cell is empty and displays appropriate warning
#'
#' @param cellContent content of the cell being checked
#' @param rowNumber the row reference to the original dataframe
#' @param columnName the name of the column that contains that cell
#' @param ddiValue The value its being compared agains
#' @return returns a boolean vallue and if conflict is detected throws warning
CheckIfCellIsEmpty <-
  function(cellContent,
           rowNumber,
           columnName,
           ddiValue) {
    isEmpty <- TRUE
    if (!is.null(cellContent) &
        !is.na(cellContent) & cellContent != "") {
      warning(
        paste(
          "Row ",
          rowNumber,
          ":",
          columnName,
          " column has value \"",
          cellContent,
          "\" but DDI value is \"",
          ddiValue,
          "\". Not overwriting"
        ),
        call. = FALSE,
        immediate. = TRUE
      )
      isEmpty <- FALSE
    }
    
    return(isEmpty)
  }

# Prevents function from writing Cat to console
SupressFunctionCatOutput <- function(x) {
  sink(tempfile())
  on.exit(sink())
  invisible(force(x))
}

#' populate variable details sheet using ddi
#'
#' @param ddi the path to the ddi file containing the necessary information
#' @param variableDetails the data frame containing unpopulated variableDetailsSheet
#' @return returns a populated variableDetails dataframe
ProcessDDIVariableDetails <- function(ddi, variableDetails) {
    variableValueList <- list()
    labeledVariables <- list()
    catStartValue <- numeric()
    catStartLabel <- character()
    variableStartLabel <- character()
    ddiMetaData <- ddi$variableMetaData
    ddiObject <- ddi$ddiObject
    # used for parcing out additional data
    detectedVariables <-
      unique(variableDetails[pkg.globals$argument.VariableStart])
    # Find extra info about the variable low and high
    valueForHighLow <- list()
    # Need to loop through every element because the xml2 names all variables var
    for (individualVariable in ddiObject$codeBook$dataDscr) {
      if (!is.null(attr(individualVariable, "name", exact = TRUE))) {
        ddiElementName <- attr(individualVariable, "name", exact = TRUE)
        if (length(detectedVariables[detectedVariables$variableStart == ddiElementName, 1]) != 0) {
          valueForHighLow[[ddiElementName]] <- individualVariable$valrng$range
          valueForHighLow[[ddiElementName]][["Type"]] <-
            ifelse(attr(individualVariable, "intrvl") == "discrete",
                   "cat",
                   "cont")
        }
      }
    }
    
    # Loop through every unique variable found in the VariableDetails
    for (variableToCheck in detectedVariables[, 1]) {
      # Check if that variable is recorded in DDI
      if (variableToCheck %in% names(ddiMetaData$varlab)) {
        # Store the label for that variable
        variableStartLabel <-
          ddiMetaData$varlab[[variableToCheck]]
        variableValueList <- list()
        # Check if that variable has value labels
        if (variableToCheck %in% names(ddiMetaData$vallab)) {
          # Loop Through all the values that are stored for that variable
          for (valueLabelToCheck in names(ddiMetaData$vallab[[variableToCheck]])) {
            catStartValue <-
              ddiMetaData$vallab[[variableToCheck]][[valueLabelToCheck]]
            catStartLabel <- valueLabelToCheck
            # Should i function out the population????
            # Needs to be a character because cant access list with decimal value or zero value
            variableValueList[[as.character(catStartValue)]] <-
              list(
                variableStartType = valueForHighLow[[variableToCheck]]$Type,
                catStartValue = catStartValue,
                catStartLabel = catStartLabel,
                variableStartLabel = variableStartLabel,
                variableStartLow = catStartValue,
                variableStartHigh = catStartValue
              )
          }
          # different values for high and low as well as cat value and label
          if (valueForHighLow[[variableToCheck]]$Type == "cont") {
            variableValueList[[as.character(variableToCheck)]] <- list(
              variableStartType = valueForHighLow[[variableToCheck]]$Type,
              catStartValue = NA,
              catStartLabel = NA,
              variableStartLabel = variableStartLabel,
              variableStartLow = attr(valueForHighLow[[variableToCheck]], "min"),
              variableStartHigh = attr(valueForHighLow[[variableToCheck]], "max")
            )
          }
          # in case there is no labels for the data
        } else{
          variableValueList[[variableToCheck]] <-
            list(
              variableStartType = valueForHighLow[[variableToCheck]]$Type,
              catStartValue = NA,
              catStartLabel = NA,
              variableStartLabel = variableStartLabel,
              variableStartLow = attr(valueForHighLow[[variableToCheck]], "min"),
              variableStartHigh = attr(valueForHighLow[[variableToCheck]], "max")
            )
        }
        # add the list of value labels to that variable
        labeledVariables[[variableToCheck]] <- variableValueList
      }
    }
    if (!length(labeledVariables)) {
      populatedVariableDeatailsSheet <- NULL
    } else{
      populatedVariableDeatailsSheet <-
        PopulateVariableDetails(variableDetails,
                                labeledVariables,
                                detectedVariables)
    }
  
  return(populatedVariableDeatailsSheet)
}

#' Retrieve docDscr stdyDscr and fileDscr from the DDI
#'
#' @param ddi the path to the ddi file containing the necessary information
#' @return returns a list containg he necissary data 
GetDDIHeader <- function(ddi){
  ddiObject <- ddi$ddiObject
  additionalDDIMetaData <- list(
    docDscr = ddiObject$codeBook$docDscr,
    stdyDscr = ddiObject$codeBook$stdyDscr,
    fileDscr = ddiObject$codeBook$fileDscr
  )
    
    return(additionalDDIMetaData)
}